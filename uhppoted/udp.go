package uhppoted

import (
	"fmt"
	"net"
	"time"
)

type udp struct {
	bindAddr      *net.UDPAddr
	broadcastAddr *net.UDPAddr
	listenAddr    *net.UDPAddr
	debug         bool
}

func (u udp) broadcast(request []byte, timeout time.Duration) ([][]byte, error) {
	replies := [][]byte{}

	if socket, err := net.ListenUDP("udp", u.bindAddr); err != nil {
		return replies, err
	} else {
		defer socket.Close()

		endpoint := socket.LocalAddr().(*net.UDPAddr)
		if endpoint.Port == u.broadcastAddr.Port {
			return replies, fmt.Errorf("invalid UDP bind address: port %d reserved for broadcast", endpoint.Port)
		}

		if _, err := socket.WriteToUDP(request, u.broadcastAddr); err != nil {
			return nil, err
		} else if u.debug {
			dump(request)
		}

		// ... read until timeout or error
		e := make(chan error)

		go func() {
			for {
				buffer := make([]byte, 1024)
				if N, _, err := socket.ReadFromUDP(buffer); err != nil {
					e <- err
				} else if N == 64 {
					replies = append(replies, buffer[0:64])
					if u.debug {
						dump(buffer[0:64])
					}
				}
			}
		}()

		select {
		case <-time.After(timeout):
			return replies, nil

		case err := <-e:
			return replies, err
		}

	}
}

func dump(packet []byte) {
	hex := "%02x %02x %02x %02x %02x %02x %02x %02x"

	for i := 0; i < 4; i++ {
		offset := i * 16
		u := packet[offset : offset+8]
		v := packet[offset+8 : offset+16]

		p := fmt.Sprintf(hex, u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7])
		q := fmt.Sprintf(hex, v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])

		fmt.Printf("   %08x  %v  %v\n", offset, p, q)
	}

	fmt.Println()
}

// 	[]byte{0x17, 0x94, 0x00, 0x00, 0x90, 0x53, 0xfb, 0x0b, 0xc0, 0xa8, 0x01, 0x65, 0xff, 0xff, 0xff, 0x00,
// 		0xc0, 0xa8, 0x01, 0x01, 0x52, 0xfd, 0xfc, 0x07, 0x21, 0x82, 0x06, 0x62, 0x20, 0x20, 0x01, 0x01,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	},
// 	[]byte{0x17, 0x94, 0x00, 0x00, 0x41, 0x78, 0x1e, 0x12, 0xc0, 0xa8, 0x01, 0x64, 0xff, 0xff, 0xff, 0x00,
// 		0xc0, 0xa8, 0x01, 0x01, 0x52, 0xfd, 0xfc, 0x07, 0x21, 0x82, 0x08, 0x92, 0x20, 0x19, 0x08, 0x15,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	},
// 	[]byte{0x17, 0x94, 0x00, 0x00, 0x78, 0x37, 0x2a, 0x18, 0xc0, 0xa8, 0x01, 0x64, 0xff, 0xff, 0xff, 0x00,
// 		0xc0, 0xa8, 0x01, 0x01, 0x00, 0x12, 0x23, 0x34, 0x45, 0x56, 0x08, 0x92, 0x20, 0x18, 0x11, 0x05,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// 	},
// }
